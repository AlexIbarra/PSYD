   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"keypad.c"
  21              	.Ltext0:
  22              		.file 1 "../src/keypad.c"
 1956              		.align	2
 1957              		.global	keypad_scan
 1959              	keypad_scan:
 1960              	.LFB0:
   1:../src/keypad.c **** /*
   2:../src/keypad.c ****  * keypad.c
   3:../src/keypad.c ****  *
   4:../src/keypad.c ****  *  Created on: 08/05/2015
   5:../src/keypad.c ****  *      Author: usuario_local
   6:../src/keypad.c ****  */
   7:../src/keypad.c **** #include <keypad.h>
   8:../src/keypad.c **** #include <s3c44b0x.h>
   9:../src/keypad.c **** #include <s3cev40.h>
  10:../src/keypad.c **** #include <timers.h>
  11:../src/keypad.c **** 
  12:../src/keypad.c **** 
  13:../src/keypad.c **** void keypad_down_isr( void );
  14:../src/keypad.c **** extern void isr_KEYPAD_dummy(void);
  15:../src/keypad.c **** 
  16:../src/keypad.c **** uint8 keypad_scan( void )
  17:../src/keypad.c **** {
 1961              		.loc 1 17 0
 1962              		.cfi_startproc
 1963              		@ Function supports interworking.
 1964              		@ args = 0, pretend = 0, frame = 8
 1965              		@ frame_needed = 1, uses_anonymous_args = 0
 1966 0000 0DC0A0E1 		mov	ip, sp
 1967              	.LCFI0:
 1968              		.cfi_def_cfa_register 12
 1969 0004 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1970 0008 04B04CE2 		sub	fp, ip, #4
 1971              		.cfi_offset 14, -8
 1972              		.cfi_offset 13, -12
 1973              		.cfi_offset 11, -16
 1974              	.LCFI1:
 1975              		.cfi_def_cfa 11, 4
 1976 000c 08D04DE2 		sub	sp, sp, #8
  18:../src/keypad.c **** 	uint8 aux;
  19:../src/keypad.c **** 	aux = *( KEYPAD_ADDR + 0x1c );
 1977              		.loc 1 19 0
 1978 0010 CC319FE5 		ldr	r3, .L25
 1979 0014 0030D3E5 		ldrb	r3, [r3, #0]
 1980 0018 0D304BE5 		strb	r3, [fp, #-13]
  20:../src/keypad.c **** 	if( (aux & 0x0f) != 0x0f )
 1981              		.loc 1 20 0
 1982 001c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1983 0020 0F3003E2 		and	r3, r3, #15
 1984 0024 0F0053E3 		cmp	r3, #15
 1985 0028 1700000A 		beq	.L2
  21:../src/keypad.c **** 	{
  22:../src/keypad.c **** 		if( (aux & 0x8) == 0 ) return KEYPAD_KEY0;
 1986              		.loc 1 22 0
 1987 002c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1988 0030 083003E2 		and	r3, r3, #8
 1989 0034 000053E3 		cmp	r3, #0
 1990 0038 0100001A 		bne	.L3
 1991              		.loc 1 22 0 is_stmt 0 discriminator 1
 1992 003c 0030A0E3 		mov	r3, #0
 1993 0040 630000EA 		b	.L4
 1994              	.L3:
  23:../src/keypad.c **** 		else if( (aux & 0x4) == 0 ) return KEYPAD_KEY1;
 1995              		.loc 1 23 0 is_stmt 1
 1996 0044 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 1997 0048 043003E2 		and	r3, r3, #4
 1998 004c 000053E3 		cmp	r3, #0
 1999 0050 0100001A 		bne	.L5
 2000              		.loc 1 23 0 is_stmt 0 discriminator 1
 2001 0054 0130A0E3 		mov	r3, #1
 2002 0058 5D0000EA 		b	.L4
 2003              	.L5:
  24:../src/keypad.c **** 		else if( (aux & 0x2) == 0 ) return KEYPAD_KEY2;
 2004              		.loc 1 24 0 is_stmt 1
 2005 005c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 2006 0060 023003E2 		and	r3, r3, #2
 2007 0064 000053E3 		cmp	r3, #0
 2008 0068 0100001A 		bne	.L6
 2009              		.loc 1 24 0 is_stmt 0 discriminator 1
 2010 006c 0230A0E3 		mov	r3, #2
 2011 0070 570000EA 		b	.L4
 2012              	.L6:
  25:../src/keypad.c **** 		else if( (aux & 0x1) == 0 ) return KEYPAD_KEY3;
 2013              		.loc 1 25 0 is_stmt 1
 2014 0074 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 2015 0078 013003E2 		and	r3, r3, #1
 2016 007c 000053E3 		cmp	r3, #0
 2017 0080 0100001A 		bne	.L2
 2018              		.loc 1 25 0 is_stmt 0 discriminator 1
 2019 0084 0330A0E3 		mov	r3, #3
 2020 0088 510000EA 		b	.L4
 2021              	.L2:
  26:../src/keypad.c **** 	}
  27:../src/keypad.c **** 
  28:../src/keypad.c **** 	aux = *(KEYPAD_ADDR + 0xFB);
 2022              		.loc 1 28 0 is_stmt 1
 2023 008c 54319FE5 		ldr	r3, .L25+4
 2024 0090 0030D3E5 		ldrb	r3, [r3, #0]
 2025 0094 0D304BE5 		strb	r3, [fp, #-13]
  29:../src/keypad.c **** 	aux = (aux & 0xF); //nos quitamos la quinta fila y devolvemos un -1 si no hay datos
 2026              		.loc 1 29 0
 2027 0098 0D305BE5 		ldrb	r3, [fp, #-13]
 2028 009c 0F3003E2 		and	r3, r3, #15
 2029 00a0 0D304BE5 		strb	r3, [fp, #-13]
  30:../src/keypad.c **** 	switch (aux){
 2030              		.loc 1 30 0
 2031 00a4 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 2032 00a8 073043E2 		sub	r3, r3, #7
 2033 00ac 070053E3 		cmp	r3, #7
 2034 00b0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2035 00b4 0F0000EA 		b	.L7
 2036              	.L12:
 2037 00b8 D8000000 		.word	.L8
 2038 00bc F8000000 		.word	.L7
 2039 00c0 F8000000 		.word	.L7
 2040 00c4 F8000000 		.word	.L7
 2041 00c8 E0000000 		.word	.L9
 2042 00cc F8000000 		.word	.L7
 2043 00d0 E8000000 		.word	.L10
 2044 00d4 F0000000 		.word	.L11
 2045              	.L8:
  31:../src/keypad.c **** 	case 7: return KEYPAD_KEY4;
 2046              		.loc 1 31 0
 2047 00d8 0430A0E3 		mov	r3, #4
 2048 00dc 3C0000EA 		b	.L4
 2049              	.L9:
  32:../src/keypad.c **** 			break;
  33:../src/keypad.c **** 	case 11:return KEYPAD_KEY5;
 2050              		.loc 1 33 0
 2051 00e0 0530A0E3 		mov	r3, #5
 2052 00e4 3A0000EA 		b	.L4
 2053              	.L10:
  34:../src/keypad.c **** 			break;
  35:../src/keypad.c **** 	case 13:return KEYPAD_KEY6;
 2054              		.loc 1 35 0
 2055 00e8 0630A0E3 		mov	r3, #6
 2056 00ec 380000EA 		b	.L4
 2057              	.L11:
  36:../src/keypad.c **** 			break;
  37:../src/keypad.c **** 	case 14:return KEYPAD_KEY7;
 2058              		.loc 1 37 0
 2059 00f0 0730A0E3 		mov	r3, #7
 2060 00f4 360000EA 		b	.L4
 2061              	.L7:
  38:../src/keypad.c **** 			break;
  39:../src/keypad.c **** 	}
  40:../src/keypad.c **** 
  41:../src/keypad.c **** 	aux = *(KEYPAD_ADDR + 0xF7);
 2062              		.loc 1 41 0
 2063 00f8 EC309FE5 		ldr	r3, .L25+8
 2064 00fc 0030D3E5 		ldrb	r3, [r3, #0]
 2065 0100 0D304BE5 		strb	r3, [fp, #-13]
  42:../src/keypad.c **** 	aux = (aux & 0xF); //nos quitamos la quinta fila y devolvemos un -1 si no hay datos
 2066              		.loc 1 42 0
 2067 0104 0D305BE5 		ldrb	r3, [fp, #-13]
 2068 0108 0F3003E2 		and	r3, r3, #15
 2069 010c 0D304BE5 		strb	r3, [fp, #-13]
  43:../src/keypad.c **** 	switch (aux){
 2070              		.loc 1 43 0
 2071 0110 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 2072 0114 073043E2 		sub	r3, r3, #7
 2073 0118 070053E3 		cmp	r3, #7
 2074 011c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2075 0120 0F0000EA 		b	.L13
 2076              	.L18:
 2077 0124 44010000 		.word	.L14
 2078 0128 64010000 		.word	.L13
 2079 012c 64010000 		.word	.L13
 2080 0130 64010000 		.word	.L13
 2081 0134 4C010000 		.word	.L15
 2082 0138 64010000 		.word	.L13
 2083 013c 54010000 		.word	.L16
 2084 0140 5C010000 		.word	.L17
 2085              	.L14:
  44:../src/keypad.c **** 	case 7:return KEYPAD_KEY8;
 2086              		.loc 1 44 0
 2087 0144 0830A0E3 		mov	r3, #8
 2088 0148 210000EA 		b	.L4
 2089              	.L15:
  45:../src/keypad.c **** 			break;
  46:../src/keypad.c **** 	case 11:return KEYPAD_KEY9;
 2090              		.loc 1 46 0
 2091 014c 0930A0E3 		mov	r3, #9
 2092 0150 1F0000EA 		b	.L4
 2093              	.L16:
  47:../src/keypad.c **** 			break;
  48:../src/keypad.c **** 	case 13:return KEYPAD_KEYA;
 2094              		.loc 1 48 0
 2095 0154 0A30A0E3 		mov	r3, #10
 2096 0158 1D0000EA 		b	.L4
 2097              	.L17:
  49:../src/keypad.c **** 			break;
  50:../src/keypad.c **** 	case 14:return KEYPAD_KEYB;
 2098              		.loc 1 50 0
 2099 015c 0B30A0E3 		mov	r3, #11
 2100 0160 1B0000EA 		b	.L4
 2101              	.L13:
  51:../src/keypad.c **** 			break;
  52:../src/keypad.c **** 	}
  53:../src/keypad.c **** 
  54:../src/keypad.c **** 	aux = *(KEYPAD_ADDR + 0xEF);
 2102              		.loc 1 54 0
 2103 0164 84309FE5 		ldr	r3, .L25+12
 2104 0168 0030D3E5 		ldrb	r3, [r3, #0]
 2105 016c 0D304BE5 		strb	r3, [fp, #-13]
  55:../src/keypad.c **** 	aux = (aux & 0xF); //nos quitamos la quinta fila y devolvemos un -1 si no hay datos
 2106              		.loc 1 55 0
 2107 0170 0D305BE5 		ldrb	r3, [fp, #-13]
 2108 0174 0F3003E2 		and	r3, r3, #15
 2109 0178 0D304BE5 		strb	r3, [fp, #-13]
  56:../src/keypad.c **** 	switch (aux){
 2110              		.loc 1 56 0
 2111 017c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 2112 0180 073043E2 		sub	r3, r3, #7
 2113 0184 070053E3 		cmp	r3, #7
 2114 0188 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2115 018c 0F0000EA 		b	.L19
 2116              	.L24:
 2117 0190 B0010000 		.word	.L20
 2118 0194 D0010000 		.word	.L19
 2119 0198 D0010000 		.word	.L19
 2120 019c D0010000 		.word	.L19
 2121 01a0 B8010000 		.word	.L21
 2122 01a4 D0010000 		.word	.L19
 2123 01a8 C0010000 		.word	.L22
 2124 01ac C8010000 		.word	.L23
 2125              	.L20:
  57:../src/keypad.c **** 	case 7:return KEYPAD_KEYC;
 2126              		.loc 1 57 0
 2127 01b0 0C30A0E3 		mov	r3, #12
 2128 01b4 060000EA 		b	.L4
 2129              	.L21:
  58:../src/keypad.c **** 			break;
  59:../src/keypad.c **** 	case 11:return KEYPAD_KEYD;
 2130              		.loc 1 59 0
 2131 01b8 0D30A0E3 		mov	r3, #13
 2132 01bc 040000EA 		b	.L4
 2133              	.L22:
  60:../src/keypad.c **** 			break;
  61:../src/keypad.c **** 	case 13:return KEYPAD_KEYE;
 2134              		.loc 1 61 0
 2135 01c0 0E30A0E3 		mov	r3, #14
 2136 01c4 020000EA 		b	.L4
 2137              	.L23:
  62:../src/keypad.c **** 			break;
  63:../src/keypad.c **** 	case 14:return KEYPAD_KEYF;
 2138              		.loc 1 63 0
 2139 01c8 0F30A0E3 		mov	r3, #15
 2140 01cc 000000EA 		b	.L4
 2141              	.L19:
  64:../src/keypad.c **** 			break;
  65:../src/keypad.c **** 	}
  66:../src/keypad.c **** 	return KEYPAD_FAILURE;
 2142              		.loc 1 66 0
 2143 01d0 FF30A0E3 		mov	r3, #255
 2144              	.L4:
  67:../src/keypad.c **** }
 2145              		.loc 1 67 0
 2146 01d4 0300A0E1 		mov	r0, r3
 2147 01d8 0CD04BE2 		sub	sp, fp, #12
 2148 01dc 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2149 01e0 1EFF2FE1 		bx	lr
 2150              	.L26:
 2151              		.align	2
 2152              	.L25:
 2153 01e4 1C000006 		.word	100663324
 2154 01e8 FB000006 		.word	100663547
 2155 01ec F7000006 		.word	100663543
 2156 01f0 EF000006 		.word	100663535
 2157              		.cfi_endproc
 2158              	.LFE0:
 2160              		.align	2
 2161              		.global	keypad_wait_keydown
 2163              	keypad_wait_keydown:
 2164              	.LFB1:
  68:../src/keypad.c **** 
  69:../src/keypad.c **** 
  70:../src/keypad.c **** void keypad_wait_keydown( uint8 scancode )
  71:../src/keypad.c **** {
 2165              		.loc 1 71 0
 2166              		.cfi_startproc
 2167              		@ Function supports interworking.
 2168              		@ args = 0, pretend = 0, frame = 8
 2169              		@ frame_needed = 1, uses_anonymous_args = 0
 2170 01f4 0DC0A0E1 		mov	ip, sp
 2171              	.LCFI2:
 2172              		.cfi_def_cfa_register 12
 2173 01f8 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2174 01fc 04B04CE2 		sub	fp, ip, #4
 2175              		.cfi_offset 14, -8
 2176              		.cfi_offset 13, -12
 2177              		.cfi_offset 11, -16
 2178              	.LCFI3:
 2179              		.cfi_def_cfa 11, 4
 2180 0200 08D04DE2 		sub	sp, sp, #8
 2181 0204 0030A0E1 		mov	r3, r0
 2182 0208 0D304BE5 		strb	r3, [fp, #-13]
  72:../src/keypad.c **** 	while(1)
  73:../src/keypad.c **** 	{
  74:../src/keypad.c **** 	while(keypad_scan()!=scancode);
 2183              		.loc 1 74 0
 2184 020c 0000A0E1 		mov	r0, r0	@ nop
 2185              	.L28:
 2186              		.loc 1 74 0 is_stmt 0 discriminator 1
 2187 0210 FEFFFFEB 		bl	keypad_scan
 2188 0214 0030A0E1 		mov	r3, r0
 2189 0218 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 2190 021c 030052E1 		cmp	r2, r3
 2191 0220 FAFFFF1A 		bne	.L28
  75:../src/keypad.c **** 
  76:../src/keypad.c **** 	sw_delay_ms( KEYPAD_KEYDOWN_DELAY );
 2192              		.loc 1 76 0 is_stmt 1
 2193 0224 1E00A0E3 		mov	r0, #30
 2194 0228 FEFFFFEB 		bl	sw_delay_ms
  77:../src/keypad.c **** 	if( scancode == keypad_scan() )
 2195              		.loc 1 77 0
 2196 022c FEFFFFEB 		bl	keypad_scan
 2197 0230 0030A0E1 		mov	r3, r0
 2198 0234 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 2199 0238 030052E1 		cmp	r2, r3
 2200 023c 0900000A 		beq	.L32
  78:../src/keypad.c **** 		return;
  79:../src/keypad.c **** 
  80:../src/keypad.c **** 	while(!(PDATG & (1<<1)));
 2201              		.loc 1 80 0
 2202 0240 0000A0E1 		mov	r0, r0	@ nop
 2203              	.L30:
 2204              		.loc 1 80 0 is_stmt 0 discriminator 1
 2205 0244 28309FE5 		ldr	r3, .L33
 2206 0248 003093E5 		ldr	r3, [r3, #0]
 2207 024c 023003E2 		and	r3, r3, #2
 2208 0250 000053E3 		cmp	r3, #0
 2209 0254 FAFFFF0A 		beq	.L30
  81:../src/keypad.c **** 	sw_delay_ms( KEYPAD_KEYUP_DELAY );
 2210              		.loc 1 81 0 is_stmt 1
 2211 0258 6400A0E3 		mov	r0, #100
 2212 025c FEFFFFEB 		bl	sw_delay_ms
  82:../src/keypad.c **** 
  83:../src/keypad.c **** 	}
 2213              		.loc 1 83 0
 2214 0260 0000A0E1 		mov	r0, r0	@ nop
  74:../src/keypad.c **** 	while(keypad_scan()!=scancode);
 2215              		.loc 1 74 0
 2216 0264 E9FFFFEA 		b	.L28
 2217              	.L32:
  84:../src/keypad.c **** 
  85:../src/keypad.c **** }
 2218              		.loc 1 85 0
 2219 0268 0CD04BE2 		sub	sp, fp, #12
 2220 026c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2221 0270 1EFF2FE1 		bx	lr
 2222              	.L34:
 2223              		.align	2
 2224              	.L33:
 2225 0274 4400D201 		.word	30539844
 2226              		.cfi_endproc
 2227              	.LFE1:
 2229              		.align	2
 2230              		.global	keypad_wait_keyup
 2232              	keypad_wait_keyup:
 2233              	.LFB2:
  86:../src/keypad.c **** 
  87:../src/keypad.c **** void keypad_wait_keyup(uint8 scancode){
 2234              		.loc 1 87 0
 2235              		.cfi_startproc
 2236              		@ Function supports interworking.
 2237              		@ args = 0, pretend = 0, frame = 8
 2238              		@ frame_needed = 1, uses_anonymous_args = 0
 2239 0278 0DC0A0E1 		mov	ip, sp
 2240              	.LCFI4:
 2241              		.cfi_def_cfa_register 12
 2242 027c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2243 0280 04B04CE2 		sub	fp, ip, #4
 2244              		.cfi_offset 14, -8
 2245              		.cfi_offset 13, -12
 2246              		.cfi_offset 11, -16
 2247              	.LCFI5:
 2248              		.cfi_def_cfa 11, 4
 2249 0284 08D04DE2 		sub	sp, sp, #8
 2250 0288 0030A0E1 		mov	r3, r0
 2251 028c 0D304BE5 		strb	r3, [fp, #-13]
  88:../src/keypad.c **** 	keypad_wait_keydown(scancode);
 2252              		.loc 1 88 0
 2253 0290 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 2254 0294 0300A0E1 		mov	r0, r3
 2255 0298 FEFFFFEB 		bl	keypad_wait_keydown
  89:../src/keypad.c **** 	while(!(PDATG & (1<<1)));		//mientras sea =0 es decir ESTE PULSADA!!!!!!
 2256              		.loc 1 89 0
 2257 029c 0000A0E1 		mov	r0, r0	@ nop
 2258              	.L36:
 2259              		.loc 1 89 0 is_stmt 0 discriminator 1
 2260 02a0 20309FE5 		ldr	r3, .L37
 2261 02a4 003093E5 		ldr	r3, [r3, #0]
 2262 02a8 023003E2 		and	r3, r3, #2
 2263 02ac 000053E3 		cmp	r3, #0
 2264 02b0 FAFFFF0A 		beq	.L36
  90:../src/keypad.c **** 		sw_delay_ms(KEYPAD_KEYUP_DELAY);
 2265              		.loc 1 90 0 is_stmt 1
 2266 02b4 6400A0E3 		mov	r0, #100
 2267 02b8 FEFFFFEB 		bl	sw_delay_ms
  91:../src/keypad.c **** 
  92:../src/keypad.c **** 
  93:../src/keypad.c **** }
 2268              		.loc 1 93 0
 2269 02bc 0CD04BE2 		sub	sp, fp, #12
 2270 02c0 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2271 02c4 1EFF2FE1 		bx	lr
 2272              	.L38:
 2273              		.align	2
 2274              	.L37:
 2275 02c8 4400D201 		.word	30539844
 2276              		.cfi_endproc
 2277              	.LFE2:
 2279              		.align	2
 2280              		.global	keypad_wait_any_keydown
 2282              	keypad_wait_any_keydown:
 2283              	.LFB3:
  94:../src/keypad.c **** void keypad_wait_any_keydown(void){
 2284              		.loc 1 94 0
 2285              		.cfi_startproc
 2286              		@ Function supports interworking.
 2287              		@ args = 0, pretend = 0, frame = 0
 2288              		@ frame_needed = 1, uses_anonymous_args = 0
 2289 02cc 0DC0A0E1 		mov	ip, sp
 2290              	.LCFI6:
 2291              		.cfi_def_cfa_register 12
 2292 02d0 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2293 02d4 04B04CE2 		sub	fp, ip, #4
 2294              		.cfi_offset 14, -8
 2295              		.cfi_offset 13, -12
 2296              		.cfi_offset 11, -16
 2297              	.LCFI7:
 2298              		.cfi_def_cfa 11, 4
  95:../src/keypad.c **** 	while((PDATG & (1<<1)));
 2299              		.loc 1 95 0
 2300 02d8 0000A0E1 		mov	r0, r0	@ nop
 2301              	.L40:
 2302              		.loc 1 95 0 is_stmt 0 discriminator 1
 2303 02dc 20309FE5 		ldr	r3, .L41
 2304 02e0 003093E5 		ldr	r3, [r3, #0]
 2305 02e4 023003E2 		and	r3, r3, #2
 2306 02e8 000053E3 		cmp	r3, #0
 2307 02ec FAFFFF1A 		bne	.L40
  96:../src/keypad.c **** 	sw_delay_ms(KEYPAD_KEYDOWN_DELAY);
 2308              		.loc 1 96 0 is_stmt 1
 2309 02f0 1E00A0E3 		mov	r0, #30
 2310 02f4 FEFFFFEB 		bl	sw_delay_ms
  97:../src/keypad.c **** 
  98:../src/keypad.c **** }
 2311              		.loc 1 98 0
 2312 02f8 0CD04BE2 		sub	sp, fp, #12
 2313 02fc 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2314 0300 1EFF2FE1 		bx	lr
 2315              	.L42:
 2316              		.align	2
 2317              	.L41:
 2318 0304 4400D201 		.word	30539844
 2319              		.cfi_endproc
 2320              	.LFE3:
 2322              		.align	2
 2323              		.global	keypad_wait_any_keyup
 2325              	keypad_wait_any_keyup:
 2326              	.LFB4:
  99:../src/keypad.c **** 
 100:../src/keypad.c **** /*
 101:../src/keypad.c ****  ** Espera a que se pulse y despulse cualquier tecla
 102:../src/keypad.c ****  */
 103:../src/keypad.c **** void keypad_wait_any_keyup(void){
 2327              		.loc 1 103 0
 2328              		.cfi_startproc
 2329              		@ Function supports interworking.
 2330              		@ args = 0, pretend = 0, frame = 0
 2331              		@ frame_needed = 1, uses_anonymous_args = 0
 2332 0308 0DC0A0E1 		mov	ip, sp
 2333              	.LCFI8:
 2334              		.cfi_def_cfa_register 12
 2335 030c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2336 0310 04B04CE2 		sub	fp, ip, #4
 2337              		.cfi_offset 14, -8
 2338              		.cfi_offset 13, -12
 2339              		.cfi_offset 11, -16
 2340              	.LCFI9:
 2341              		.cfi_def_cfa 11, 4
 104:../src/keypad.c **** 
 105:../src/keypad.c **** 	keypad_wait_any_keydown();
 2342              		.loc 1 105 0
 2343 0314 FEFFFFEB 		bl	keypad_wait_any_keydown
 106:../src/keypad.c **** 	while(!(PDATG & (1<<1)));
 2344              		.loc 1 106 0
 2345 0318 0000A0E1 		mov	r0, r0	@ nop
 2346              	.L44:
 2347              		.loc 1 106 0 is_stmt 0 discriminator 1
 2348 031c 20309FE5 		ldr	r3, .L45
 2349 0320 003093E5 		ldr	r3, [r3, #0]
 2350 0324 023003E2 		and	r3, r3, #2
 2351 0328 000053E3 		cmp	r3, #0
 2352 032c FAFFFF0A 		beq	.L44
 107:../src/keypad.c **** 		sw_delay_ms(KEYPAD_KEYUP_DELAY);
 2353              		.loc 1 107 0 is_stmt 1
 2354 0330 6400A0E3 		mov	r0, #100
 2355 0334 FEFFFFEB 		bl	sw_delay_ms
 108:../src/keypad.c **** 
 109:../src/keypad.c **** 
 110:../src/keypad.c **** }
 2356              		.loc 1 110 0
 2357 0338 0CD04BE2 		sub	sp, fp, #12
 2358 033c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2359 0340 1EFF2FE1 		bx	lr
 2360              	.L46:
 2361              		.align	2
 2362              	.L45:
 2363 0344 4400D201 		.word	30539844
 2364              		.cfi_endproc
 2365              	.LFE4:
 2367              		.align	2
 2368              		.global	keypad_getchar
 2370              	keypad_getchar:
 2371              	.LFB5:
 111:../src/keypad.c **** 
 112:../src/keypad.c **** uint8 keypad_getchar(void){
 2372              		.loc 1 112 0
 2373              		.cfi_startproc
 2374              		@ Function supports interworking.
 2375              		@ args = 0, pretend = 0, frame = 0
 2376              		@ frame_needed = 1, uses_anonymous_args = 0
 2377 0348 0DC0A0E1 		mov	ip, sp
 2378              	.LCFI10:
 2379              		.cfi_def_cfa_register 12
 2380 034c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2381 0350 04B04CE2 		sub	fp, ip, #4
 2382              		.cfi_offset 14, -8
 2383              		.cfi_offset 13, -12
 2384              		.cfi_offset 11, -16
 2385              	.LCFI11:
 2386              		.cfi_def_cfa 11, 4
 113:../src/keypad.c **** 	keypad_wait_any_keydown();
 2387              		.loc 1 113 0
 2388 0354 FEFFFFEB 		bl	keypad_wait_any_keydown
 114:../src/keypad.c **** 	return keypad_scan();
 2389              		.loc 1 114 0
 2390 0358 FEFFFFEB 		bl	keypad_scan
 2391 035c 0030A0E1 		mov	r3, r0
 115:../src/keypad.c **** 
 116:../src/keypad.c **** }
 2392              		.loc 1 116 0
 2393 0360 0300A0E1 		mov	r0, r3
 2394 0364 0CD04BE2 		sub	sp, fp, #12
 2395 0368 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2396 036c 1EFF2FE1 		bx	lr
 2397              		.cfi_endproc
 2398              	.LFE5:
 2400              		.align	2
 2401              		.global	keypad_getchartime
 2403              	keypad_getchartime:
 2404              	.LFB6:
 117:../src/keypad.c **** 
 118:../src/keypad.c **** /*
 119:../src/keypad.c ****  ** Espera la pulsaci�n de una tecla del keypad y devuelve su scancode y el intervalo en ms que h
 120:../src/keypad.c ****  */
 121:../src/keypad.c **** uint8 keypad_getchartime(uint16 *ms){
 2405              		.loc 1 121 0
 2406              		.cfi_startproc
 2407              		@ Function supports interworking.
 2408              		@ args = 0, pretend = 0, frame = 16
 2409              		@ frame_needed = 1, uses_anonymous_args = 0
 2410 0370 0DC0A0E1 		mov	ip, sp
 2411              	.LCFI12:
 2412              		.cfi_def_cfa_register 12
 2413 0374 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2414 0378 04B04CE2 		sub	fp, ip, #4
 2415              		.cfi_offset 14, -8
 2416              		.cfi_offset 13, -12
 2417              		.cfi_offset 11, -16
 2418              	.LCFI13:
 2419              		.cfi_def_cfa 11, 4
 2420 037c 10D04DE2 		sub	sp, sp, #16
 2421 0380 18000BE5 		str	r0, [fp, #-24]
 122:../src/keypad.c **** 	uint8 value = KEYPAD_FAILURE;
 2422              		.loc 1 122 0
 2423 0384 0030E0E3 		mvn	r3, #0
 2424 0388 0D304BE5 		strb	r3, [fp, #-13]
 123:../src/keypad.c **** 	while((PDATG & (1<<1)));
 2425              		.loc 1 123 0
 2426 038c 0000A0E1 		mov	r0, r0	@ nop
 2427              	.L49:
 2428              		.loc 1 123 0 is_stmt 0 discriminator 1
 2429 0390 84309FE5 		ldr	r3, .L51
 2430 0394 003093E5 		ldr	r3, [r3, #0]
 2431 0398 023003E2 		and	r3, r3, #2
 2432 039c 000053E3 		cmp	r3, #0
 2433 03a0 FAFFFF1A 		bne	.L49
 124:../src/keypad.c **** 	timer3_start();
 2434              		.loc 1 124 0 is_stmt 1
 2435 03a4 FEFFFFEB 		bl	timer3_start
 125:../src/keypad.c **** 	sw_delay_ms(PB_KEYDOWN_DELAY);
 2436              		.loc 1 125 0
 2437 03a8 1E00A0E3 		mov	r0, #30
 2438 03ac FEFFFFEB 		bl	sw_delay_ms
 126:../src/keypad.c **** 	int temp=keypad_getchar();
 2439              		.loc 1 126 0
 2440 03b0 FEFFFFEB 		bl	keypad_getchar
 2441 03b4 0030A0E1 		mov	r3, r0
 2442 03b8 14300BE5 		str	r3, [fp, #-20]
 127:../src/keypad.c **** 	while(!(PDATG & (1<<1)));
 2443              		.loc 1 127 0
 2444 03bc 0000A0E1 		mov	r0, r0	@ nop
 2445              	.L50:
 2446              		.loc 1 127 0 is_stmt 0 discriminator 1
 2447 03c0 54309FE5 		ldr	r3, .L51
 2448 03c4 003093E5 		ldr	r3, [r3, #0]
 2449 03c8 023003E2 		and	r3, r3, #2
 2450 03cc 000053E3 		cmp	r3, #0
 2451 03d0 FAFFFF0A 		beq	.L50
 128:../src/keypad.c **** 	*ms = timer3_stop() / 10; //Paro temporizador
 2452              		.loc 1 128 0 is_stmt 1
 2453 03d4 FEFFFFEB 		bl	timer3_stop
 2454 03d8 0030A0E1 		mov	r3, r0
 2455 03dc 0320A0E1 		mov	r2, r3
 2456 03e0 38309FE5 		ldr	r3, .L51+4
 2457 03e4 921383E0 		umull	r1, r3, r2, r3
 2458 03e8 A331A0E1 		mov	r3, r3, lsr #3
 2459 03ec 0338A0E1 		mov	r3, r3, asl #16
 2460 03f0 2328A0E1 		mov	r2, r3, lsr #16
 2461 03f4 18301BE5 		ldr	r3, [fp, #-24]
 2462 03f8 B020C3E1 		strh	r2, [r3, #0]	@ movhi
 129:../src/keypad.c **** 	sw_delay_ms(PB_KEYUP_DELAY);
 2463              		.loc 1 129 0
 2464 03fc 6400A0E3 		mov	r0, #100
 2465 0400 FEFFFFEB 		bl	sw_delay_ms
 130:../src/keypad.c **** 	return temp;
 2466              		.loc 1 130 0
 2467 0404 14301BE5 		ldr	r3, [fp, #-20]
 2468 0408 FF3003E2 		and	r3, r3, #255
 131:../src/keypad.c **** }
 2469              		.loc 1 131 0
 2470 040c 0300A0E1 		mov	r0, r3
 2471 0410 0CD04BE2 		sub	sp, fp, #12
 2472 0414 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2473 0418 1EFF2FE1 		bx	lr
 2474              	.L52:
 2475              		.align	2
 2476              	.L51:
 2477 041c 4400D201 		.word	30539844
 2478 0420 CDCCCCCC 		.word	-858993459
 2479              		.cfi_endproc
 2480              	.LFE6:
 2482              		.align	2
 2483              		.global	keypad_timeout_getchar
 2485              	keypad_timeout_getchar:
 2486              	.LFB7:
 132:../src/keypad.c **** 
 133:../src/keypad.c **** /*
 134:../src/keypad.c ****  ** Espera hasta un m�ximo de n segundos la pulsaci�n de una tecla del keypad y devuelve su sca
 135:../src/keypad.c ****  */
 136:../src/keypad.c **** uint8 keypad_timeout_getchar(uint16 n){
 2487              		.loc 1 136 0
 2488              		.cfi_startproc
 2489              		@ Function supports interworking.
 2490              		@ args = 0, pretend = 0, frame = 8
 2491              		@ frame_needed = 1, uses_anonymous_args = 0
 2492 0424 0DC0A0E1 		mov	ip, sp
 2493              	.LCFI14:
 2494              		.cfi_def_cfa_register 12
 2495 0428 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2496 042c 04B04CE2 		sub	fp, ip, #4
 2497              		.cfi_offset 14, -8
 2498              		.cfi_offset 13, -12
 2499              		.cfi_offset 11, -16
 2500              	.LCFI15:
 2501              		.cfi_def_cfa 11, 4
 2502 0430 08D04DE2 		sub	sp, sp, #8
 2503 0434 0030A0E1 		mov	r3, r0
 2504 0438 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
 137:../src/keypad.c **** 	timer3_start_timeout(n*10000);
 2505              		.loc 1 137 0
 2506 043c BE305BE1 		ldrh	r3, [fp, #-14]	@ movhi
 2507 0440 0320A0E1 		mov	r2, r3	@ movhi
 2508 0444 8222A0E1 		mov	r2, r2, asl #5
 2509 0448 022063E0 		rsb	r2, r3, r2
 2510 044c 0221A0E1 		mov	r2, r2, asl #2
 2511 0450 033082E0 		add	r3, r2, r3
 2512 0454 0320A0E1 		mov	r2, r3	@ movhi
 2513 0458 0211A0E1 		mov	r1, r2, asl #2
 2514 045c 0320A0E1 		mov	r2, r3	@ movhi
 2515 0460 0130A0E1 		mov	r3, r1	@ movhi
 2516 0464 033082E0 		add	r3, r2, r3
 2517 0468 0332A0E1 		mov	r3, r3, asl #4
 2518 046c 0338A0E1 		mov	r3, r3, asl #16
 2519 0470 2338A0E1 		mov	r3, r3, lsr #16
 2520 0474 0300A0E1 		mov	r0, r3
 2521 0478 FEFFFFEB 		bl	timer3_start_timeout
 138:../src/keypad.c **** 	while ((!(timer3_timeout()))|| (!(PDATG & (1<<1))));
 2522              		.loc 1 138 0
 2523 047c 0000A0E1 		mov	r0, r0	@ nop
 2524              	.L54:
 2525              		.loc 1 138 0 is_stmt 0 discriminator 1
 2526 0480 FEFFFFEB 		bl	timer3_timeout
 2527 0484 0030A0E1 		mov	r3, r0
 2528 0488 000053E3 		cmp	r3, #0
 2529 048c FBFFFF0A 		beq	.L54
 2530              		.loc 1 138 0 discriminator 2
 2531 0490 30309FE5 		ldr	r3, .L55
 2532 0494 003093E5 		ldr	r3, [r3, #0]
 2533 0498 023003E2 		and	r3, r3, #2
 2534 049c 000053E3 		cmp	r3, #0
 2535 04a0 F6FFFF0A 		beq	.L54
 139:../src/keypad.c **** 	timer3_start();
 2536              		.loc 1 139 0 is_stmt 1
 2537 04a4 FEFFFFEB 		bl	timer3_start
 140:../src/keypad.c **** 	sw_delay_ms(PB_KEYDOWN_DELAY);
 2538              		.loc 1 140 0
 2539 04a8 1E00A0E3 		mov	r0, #30
 2540 04ac FEFFFFEB 		bl	sw_delay_ms
 141:../src/keypad.c **** 	return keypad_getchar();
 2541              		.loc 1 141 0
 2542 04b0 FEFFFFEB 		bl	keypad_getchar
 2543 04b4 0030A0E1 		mov	r3, r0
 142:../src/keypad.c **** 
 143:../src/keypad.c **** 
 144:../src/keypad.c **** }
 2544              		.loc 1 144 0
 2545 04b8 0300A0E1 		mov	r0, r3
 2546 04bc 0CD04BE2 		sub	sp, fp, #12
 2547 04c0 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2548 04c4 1EFF2FE1 		bx	lr
 2549              	.L56:
 2550              		.align	2
 2551              	.L55:
 2552 04c8 4400D201 		.word	30539844
 2553              		.cfi_endproc
 2554              	.LFE7:
 2556              		.align	2
 2557              		.global	keypad_open
 2559              	keypad_open:
 2560              	.LFB8:
 145:../src/keypad.c **** 
 146:../src/keypad.c **** void keypad_open(void (* isr)(void)){
 2561              		.loc 1 146 0
 2562              		.cfi_startproc
 2563              		@ Function supports interworking.
 2564              		@ args = 0, pretend = 0, frame = 8
 2565              		@ frame_needed = 1, uses_anonymous_args = 0
 2566 04cc 0DC0A0E1 		mov	ip, sp
 2567              	.LCFI16:
 2568              		.cfi_def_cfa_register 12
 2569 04d0 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2570 04d4 04B04CE2 		sub	fp, ip, #4
 2571              		.cfi_offset 14, -8
 2572              		.cfi_offset 13, -12
 2573              		.cfi_offset 11, -16
 2574              	.LCFI17:
 2575              		.cfi_def_cfa 11, 4
 2576 04d8 08D04DE2 		sub	sp, sp, #8
 2577 04dc 10000BE5 		str	r0, [fp, #-16]
 147:../src/keypad.c **** 	pISR_KEYPAD= ((uint32)isr);
 2578              		.loc 1 147 0
 2579 04e0 3C309FE5 		ldr	r3, .L58
 2580 04e4 10201BE5 		ldr	r2, [fp, #-16]
 2581 04e8 002083E5 		str	r2, [r3, #0]
 148:../src/keypad.c **** 	EXTINTPND = ~0;
 2582              		.loc 1 148 0
 2583 04ec 34309FE5 		ldr	r3, .L58+4
 2584 04f0 0020E0E3 		mvn	r2, #0
 2585 04f4 002083E5 		str	r2, [r3, #0]
 149:../src/keypad.c **** 	I_ISPC = BIT_KEYPAD;
 2586              		.loc 1 149 0
 2587 04f8 2C309FE5 		ldr	r3, .L58+8
 2588 04fc 0124A0E3 		mov	r2, #16777216
 2589 0500 002083E5 		str	r2, [r3, #0]
 150:../src/keypad.c **** 	INTMSK &= ~(BIT_GLOBAL | BIT_KEYPAD);
 2590              		.loc 1 150 0
 2591 0504 24309FE5 		ldr	r3, .L58+12
 2592 0508 20209FE5 		ldr	r2, .L58+12
 2593 050c 002092E5 		ldr	r2, [r2, #0]
 2594 0510 0524C2E3 		bic	r2, r2, #83886080
 2595 0514 002083E5 		str	r2, [r3, #0]
 151:../src/keypad.c **** 
 152:../src/keypad.c **** }
 2596              		.loc 1 152 0
 2597 0518 0CD04BE2 		sub	sp, fp, #12
 2598 051c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2599 0520 1EFF2FE1 		bx	lr
 2600              	.L59:
 2601              		.align	2
 2602              	.L58:
 2603 0524 80FF7F0C 		.word	209715072
 2604 0528 5400D201 		.word	30539860
 2605 052c 2400E001 		.word	31457316
 2606 0530 0C00E001 		.word	31457292
 2607              		.cfi_endproc
 2608              	.LFE8:
 2610              		.align	2
 2611              		.global	keypad_close
 2613              	keypad_close:
 2614              	.LFB9:
 153:../src/keypad.c **** 
 154:../src/keypad.c **** /*
 155:../src/keypad.c ****  ** Deshabilita las interrupciones por pulsaci�n del keypad
 156:../src/keypad.c ****  ** Desinstala la RTI por pulsaci�n del keypad
 157:../src/keypad.c ****  */
 158:../src/keypad.c **** void keypad_close(void){
 2615              		.loc 1 158 0
 2616              		.cfi_startproc
 2617              		@ Function supports interworking.
 2618              		@ args = 0, pretend = 0, frame = 0
 2619              		@ frame_needed = 1, uses_anonymous_args = 0
 2620 0534 0DC0A0E1 		mov	ip, sp
 2621              	.LCFI18:
 2622              		.cfi_def_cfa_register 12
 2623 0538 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2624 053c 04B04CE2 		sub	fp, ip, #4
 2625              		.cfi_offset 14, -8
 2626              		.cfi_offset 13, -12
 2627              		.cfi_offset 11, -16
 2628              	.LCFI19:
 2629              		.cfi_def_cfa 11, 4
 159:../src/keypad.c **** 	INTMSK |= (BIT_KEYPAD);
 2630              		.loc 1 159 0
 2631 0540 24309FE5 		ldr	r3, .L61
 2632 0544 20209FE5 		ldr	r2, .L61
 2633 0548 002092E5 		ldr	r2, [r2, #0]
 2634 054c 012482E3 		orr	r2, r2, #16777216
 2635 0550 002083E5 		str	r2, [r3, #0]
 160:../src/keypad.c **** 	pISR_KEYPAD= (uint32)isr_KEYPAD_dummy;
 2636              		.loc 1 160 0
 2637 0554 14309FE5 		ldr	r3, .L61+4
 2638 0558 14209FE5 		ldr	r2, .L61+8
 2639 055c 002083E5 		str	r2, [r3, #0]
 161:../src/keypad.c **** }
 2640              		.loc 1 161 0
 2641 0560 0CD04BE2 		sub	sp, fp, #12
 2642 0564 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2643 0568 1EFF2FE1 		bx	lr
 2644              	.L62:
 2645              		.align	2
 2646              	.L61:
 2647 056c 0C00E001 		.word	31457292
 2648 0570 80FF7F0C 		.word	209715072
 2649 0574 00000000 		.word	isr_KEYPAD_dummy
 2650              		.cfi_endproc
 2651              	.LFE9:
 2653              		.align	2
 2654              		.global	keypad_up_isr
 2656              	keypad_up_isr:
 2657              	.LFB10:
 162:../src/keypad.c **** 
 163:../src/keypad.c **** void keypad_up_isr( void )
 164:../src/keypad.c **** {
 2658              		.loc 1 164 0
 2659              		.cfi_startproc
 2660              		@ Function supports interworking.
 2661              		@ args = 0, pretend = 0, frame = 0
 2662              		@ frame_needed = 1, uses_anonymous_args = 0
 2663 0578 0DC0A0E1 		mov	ip, sp
 2664              	.LCFI20:
 2665              		.cfi_def_cfa_register 12
 2666 057c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2667 0580 04B04CE2 		sub	fp, ip, #4
 2668              		.cfi_offset 14, -8
 2669              		.cfi_offset 13, -12
 2670              		.cfi_offset 11, -16
 2671              	.LCFI21:
 2672              		.cfi_def_cfa 11, 4
 165:../src/keypad.c **** sw_delay_ms( KEYPAD_KEYUP_DELAY );
 2673              		.loc 1 165 0
 2674 0584 6400A0E3 		mov	r0, #100
 2675 0588 FEFFFFEB 		bl	sw_delay_ms
 166:../src/keypad.c **** EXTINT = (EXTINT & ~(0xf<<4)) | (2<<4);
 2676              		.loc 1 166 0
 2677 058c 30309FE5 		ldr	r3, .L64
 2678 0590 2C209FE5 		ldr	r2, .L64
 2679 0594 002092E5 		ldr	r2, [r2, #0]
 2680 0598 F020C2E3 		bic	r2, r2, #240
 2681 059c 202082E3 		orr	r2, r2, #32
 2682 05a0 002083E5 		str	r2, [r3, #0]
 167:../src/keypad.c **** keypad_open( keypad_down_isr );
 2683              		.loc 1 167 0
 2684 05a4 1C009FE5 		ldr	r0, .L64+4
 2685 05a8 FEFFFFEB 		bl	keypad_open
 168:../src/keypad.c **** I_ISPC = BIT_KEYPAD;
 2686              		.loc 1 168 0
 2687 05ac 18309FE5 		ldr	r3, .L64+8
 2688 05b0 0124A0E3 		mov	r2, #16777216
 2689 05b4 002083E5 		str	r2, [r3, #0]
 169:../src/keypad.c **** }
 2690              		.loc 1 169 0
 2691 05b8 0CD04BE2 		sub	sp, fp, #12
 2692 05bc 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2693 05c0 1EFF2FE1 		bx	lr
 2694              	.L65:
 2695              		.align	2
 2696              	.L64:
 2697 05c4 5000D201 		.word	30539856
 2698 05c8 00000000 		.word	keypad_down_isr
 2699 05cc 2400E001 		.word	31457316
 2700              		.cfi_endproc
 2701              	.LFE10:
 2703              		.align	2
 2704              		.global	keypad_down_isr
 2706              	keypad_down_isr:
 2707              	.LFB11:
 170:../src/keypad.c **** void keypad_down_isr( void )
 171:../src/keypad.c **** {
 2708              		.loc 1 171 0
 2709              		.cfi_startproc
 2710              		@ Function supports interworking.
 2711              		@ args = 0, pretend = 0, frame = 0
 2712              		@ frame_needed = 1, uses_anonymous_args = 0
 2713 05d0 0DC0A0E1 		mov	ip, sp
 2714              	.LCFI22:
 2715              		.cfi_def_cfa_register 12
 2716 05d4 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2717 05d8 04B04CE2 		sub	fp, ip, #4
 2718              		.cfi_offset 14, -8
 2719              		.cfi_offset 13, -12
 2720              		.cfi_offset 11, -16
 2721              	.LCFI23:
 2722              		.cfi_def_cfa 11, 4
 172:../src/keypad.c **** 	sw_delay_ms( KEYPAD_KEYDOWN_DELAY );
 2723              		.loc 1 172 0
 2724 05dc 1E00A0E3 		mov	r0, #30
 2725 05e0 FEFFFFEB 		bl	sw_delay_ms
 173:../src/keypad.c **** 
 174:../src/keypad.c **** 	EXTINT = (EXTINT & ~(0xf<<4)) | (4<<4);
 2726              		.loc 1 174 0
 2727 05e4 30309FE5 		ldr	r3, .L67
 2728 05e8 2C209FE5 		ldr	r2, .L67
 2729 05ec 002092E5 		ldr	r2, [r2, #0]
 2730 05f0 F020C2E3 		bic	r2, r2, #240
 2731 05f4 402082E3 		orr	r2, r2, #64
 2732 05f8 002083E5 		str	r2, [r3, #0]
 175:../src/keypad.c **** 	keypad_open( keypad_up_isr );
 2733              		.loc 1 175 0
 2734 05fc 1C009FE5 		ldr	r0, .L67+4
 2735 0600 FEFFFFEB 		bl	keypad_open
 176:../src/keypad.c **** 	I_ISPC = BIT_KEYPAD;
 2736              		.loc 1 176 0
 2737 0604 18309FE5 		ldr	r3, .L67+8
 2738 0608 0124A0E3 		mov	r2, #16777216
 2739 060c 002083E5 		str	r2, [r3, #0]
 177:../src/keypad.c **** }
 2740              		.loc 1 177 0
 2741 0610 0CD04BE2 		sub	sp, fp, #12
 2742 0614 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2743 0618 1EFF2FE1 		bx	lr
 2744              	.L68:
 2745              		.align	2
 2746              	.L67:
 2747 061c 5000D201 		.word	30539856
 2748 0620 00000000 		.word	keypad_up_isr
 2749 0624 2400E001 		.word	31457316
 2750              		.cfi_endproc
 2751              	.LFE11:
 2753              		.align	2
 2754              		.global	keypad_init
 2756              	keypad_init:
 2757              	.LFB12:
 178:../src/keypad.c **** 
 179:../src/keypad.c **** void keypad_init(void) {
 2758              		.loc 1 179 0
 2759              		.cfi_startproc
 2760              		@ Function supports interworking.
 2761              		@ args = 0, pretend = 0, frame = 0
 2762              		@ frame_needed = 1, uses_anonymous_args = 0
 2763 0628 0DC0A0E1 		mov	ip, sp
 2764              	.LCFI24:
 2765              		.cfi_def_cfa_register 12
 2766 062c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2767 0630 04B04CE2 		sub	fp, ip, #4
 2768              		.cfi_offset 14, -8
 2769              		.cfi_offset 13, -12
 2770              		.cfi_offset 11, -16
 2771              	.LCFI25:
 2772              		.cfi_def_cfa 11, 4
 180:../src/keypad.c **** 	timers_init();
 2773              		.loc 1 180 0
 2774 0634 FEFFFFEB 		bl	timers_init
 181:../src/keypad.c **** 
 182:../src/keypad.c **** }
 2775              		.loc 1 182 0
 2776 0638 0CD04BE2 		sub	sp, fp, #12
 2777 063c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2778 0640 1EFF2FE1 		bx	lr
 2779              		.cfi_endproc
 2780              	.LFE12:
 2782              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 keypad.c
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:1956   .text:00000000 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:1959   .text:00000000 keypad_scan
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2037   .text:000000b8 $d
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2047   .text:000000d8 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2077   .text:00000124 $d
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2087   .text:00000144 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2117   .text:00000190 $d
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2127   .text:000001b0 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2153   .text:000001e4 $d
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2160   .text:000001f4 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2163   .text:000001f4 keypad_wait_keydown
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2225   .text:00000274 $d
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2229   .text:00000278 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2232   .text:00000278 keypad_wait_keyup
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2275   .text:000002c8 $d
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2279   .text:000002cc $a
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2282   .text:000002cc keypad_wait_any_keydown
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2318   .text:00000304 $d
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2322   .text:00000308 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2325   .text:00000308 keypad_wait_any_keyup
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2363   .text:00000344 $d
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2367   .text:00000348 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2370   .text:00000348 keypad_getchar
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2403   .text:00000370 keypad_getchartime
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2477   .text:0000041c $d
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2482   .text:00000424 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2485   .text:00000424 keypad_timeout_getchar
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2552   .text:000004c8 $d
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2556   .text:000004cc $a
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2559   .text:000004cc keypad_open
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2603   .text:00000524 $d
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2610   .text:00000534 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2613   .text:00000534 keypad_close
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2647   .text:0000056c $d
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2653   .text:00000578 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2656   .text:00000578 keypad_up_isr
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2697   .text:000005c4 $d
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2706   .text:000005d0 keypad_down_isr
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2703   .text:000005d0 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2747   .text:0000061c $d
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2753   .text:00000628 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccvvxNTP.s:2756   .text:00000628 keypad_init
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
sw_delay_ms
timer3_start
timer3_stop
timer3_start_timeout
timer3_timeout
isr_KEYPAD_dummy
timers_init
